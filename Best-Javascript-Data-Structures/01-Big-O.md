# 01 - 빅오(Big O)

## 빅오 표기법의 필요성

하나의 결과를 도출하기 위한 수 만가지의 방법 중 어느것이 더 좋은지, 더 효율적인지 어떻게 알 수 있을까?
`빅오 표기법`는 여러가지 코드를 서로 비교하고 성능을 평가하는 방법이다.

```jsx
// 1번
function addUpTo(n) {
	let total = 0;
    for (let i = 1; i <= n; i++ {
    	total += i;
    }
    return total;
}

// 2번
function addUpTo(n) {
	return n * (n + 1) / 2
}
```

위의 1번과 2번 코드 중 `더 나은 것(좋은 코드)`은 무엇을 의미할까?

- **어떤 코드의 실행 속도가 더 빠른가?**
- **메모리를 얼마나 사용하는가?**
- 코드를 얼마나 쉽게 읽을 수 있는가?

우선, 코드의 실행 속도를 평가하는 방법에 대해 알아보자

performance.now()를 사용하면 코드의 실행 속도를 측정할 수 있다.
정확히 설명하자면, performance.now()는 브라우저가 문서를 만드는 시간, 창이 열린 시간을 측정해준다.

하지만, performance.now()로 속도를 측정하기에는 몇가지 문제점이 있다.

- 기기에 따라 다르게 측정된다.
- 같은 기기에서 동일한 코드를 실행할 때 마다 다르게 측정된다.
- 빠른 알고리즘은 정말 짦은 시간안에 모든 것들이 처리되기 때문에, 작은 차이를 비교하기에는 역부족이다.

그렇다면, 코드를 살펴보면서 시간을 측정하지 않고 어느 코드가 더 좋은지 어떻게 비교할 수 있을까?
시간을 측정하는 대신, **컴퓨터가 처리해야하는 연산의 갯수를 세면 된다.**

1번, 2번 코드를 통해 연산 갯수는 각각 어떠한 차이를 보이는지 알아보자.

![1번](https://velog.velcdn.com/images/my__memoeia/post/de43c171-1618-454d-b828-e5ab5408ef16/image.png)

1번

![2번](https://velog.velcdn.com/images/my__memoeia/post/02c7246b-1c77-4323-b365-142367dcfd93/image.png)

2번

빅오를 볼 땐, 정확한 연산 횟수를 파악하는 것이 아닌 **전체적인 추세를 보는 것**이 중요하다. 1번 코드로 예를들면, N이 커질수록 연산의 갯수도 비례적으로 늘어난다는 것 정도만 파악하면 된다.

## 빅오

그렇다면, 빅오란 무엇일까

- 대략적으로 숫자를 세는 것에 붙인 공식적인 표현
- 정식적으로 입력된 내용이 늘어날수록 알고리즘 실행 시간이 어떻게 변하는지를 설명하는 공식적인 방식
- 입력 크기와 실행 시간의 관계를 의미

오로지 전반적인 추세에 주목하며, 빅오 표기법에 대해 알아보자

## 빅오 표기법을 표현하는 방법

**1. O(n) : n이 증가할 수록 커지는 연산 횟수**

```jsx
// 예제 1
for (let i = 0; i < n; i++) {
  console.log(i);
}
```

예제1은 n이 커질수록 루프 안의 연산을 실행하는 횟수가 늘어나기 때문에 O(n)이다.
즉 n만큼의 연산이 일어나기 때문에 O(n)이라고 할 수 있다.

```jsx
// 예제 2
  for (let j = n - 1; j >= 0; j--) {
    console.log(j);
```

예제2 또한, n만큼의 연산이 일어나는 것이기 때문에 O(n)이다.

```jsx
// 예제 3
function count(n) {
  console.log("up");
  for (let i = 0; i < n; i++) {
    console.log(i);
  }
  console.log("down");
  for (let j = n - 1; j >= n; j--) {
    console.log(j);
  }
}
```

예제3은 O(n)과 O(n)의 조합이다.
따라서 O(2n)으로 생각할 수도 있지만, 틀렸다.
빅오 표기에서는 상수를 무시하기 때문에 2n은 n으로 간주한다.

**2. O(n^2)**

```jsx
// 예제 4
function print(n) {
  for (const i = 0; i < n; i++) {
    for (const j = 0; j < n; j++) {
      console.log(i, j);
    }
  }
}
```

예제4는 위와 다르게 중첩이 되어있다.
즉, n번씩 실행하는 코드안에 또 n번씩 실행하는 코드가 있다는 것이다.
이렇게 O(n) 연산 안에 O(n)연산이 중첩되어 있으면 O(n^2) n의 제곱이 된다.

여기서, n이 커질수록 실행 시간이 n 제곱 값으로 늘어난다.

## 빅오 표현식 단순화

**1. 상수항 무시**

상수는 무시하여 최대한 단순하게 표현한다.

```jsx
O(100) => O(1)
O(2n) => O(n)
O(10n^2) => O(n^2)
```

**2. 최고차항만 표시**

최고차항만 남긴다.

```jsx
O(5n + 10) => O(n)
O(n^2 + 2n + 5) => O(n^2)
```

## 공간 복잡도(Space complexity)

입력이 커질수록 알고리즘이 얼마나 많은 공간을 차지하는지에 대해서 알아보자.
이제는 공간 즉, `사용되는 메모리`에 주목하자.
우리는 공간 중에서도 `알고리즘 자체가 필요로 하는 공간(보조 공간 복잡도)`에 주목해야한다.

그 전에, 몇가지 규칙이 있다.

- 불리언, 숫자 undefined, null은 모두 불변 공간이다.
- 문자열은 O(n)의 공간을 갖는다.
- reference타입 (객체, 배열 등)은 대부분 O(n)이다.
- O(n)에서의 n은 배열의 길이이거나 객체 키 값의 갯수이다.

이제 예시를 보자.

```jsx
// 예제 5
function sum(arr) {
  let total = 0;
  for (let i = 0; i < arr.length; i++) {
    total += arr[i];
  }
  return total;
}
```

예제5는 배열의 길이에 따라서 새로운 변수에 더하는 것이 아니다.
오로지 total 변수에 더하는 것만 하고있다.
즉, 새로운 변수를 만들지 않으므로 `O(1) 상수 공간`이다.

```jsx
예제 6
function double(arr) {
  let newArr = [];
  for (let i = 0; i < arr.length; i++) {
    newArr.push(2 * arr[i]);
  }
  return newArr;
}
```

예제6은 우선 새로운 배열을 만들고, 그런 다음 첫 번째 배령 값들을 루프로 접근해서 곱한 후 새로운 배열에 푸시하여 반환한다.
그렇기 때문에 차지하는 공간은 입력된 배열의 크기와 비례해서 커진다.
즉, 주어진 배열의 길이에 따라 메모리공간이 결정되므로 공간복잡도는 `O(N)`이다.
